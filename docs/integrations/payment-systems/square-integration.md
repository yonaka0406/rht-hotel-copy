# Square Payment Integration

This document outlines the conceptual design for integrating Square's payment link functionality with the Property Management System (PMS).

## Overview

The Square payment integration enables the PMS to generate secure payment links for guests, process payments through Square's platform, and automatically update reservation payment status based on webhook notifications from Square.

### Key Features
- Generate Square payment links for reservations
- Secure payment processing through Square
- Automatic payment status updates via webhooks
- PCI DSS compliance through Square's platform
- Comprehensive audit trail and reconciliation

## Generating Square Payment Links

### API Call to Square

**Endpoint:** `POST /v2/online-checkout/payment-links`

**Authentication:** Bearer token using the Square API secret key. This key must be securely stored and managed.

### Key Request Payload Fields

#### idempotency_key (Required)
A unique string (e.g., UUID generated by the PMS) that identifies this `CreatePaymentLink` request. Square uses this to prevent processing the same request multiple times if there are network issues or retries.

**Importance**: Ensures a payment link is not accidentally created multiple times for the same payment intent.

#### description (Optional but recommended)
A brief description of the payment link, visible to the merchant in the Square dashboard (e.g., "Reservation #12345 - Initial Payment"). Not typically shown to the customer on the payment page.

#### quick_pay (Primary method)
For creating a link for a single, ad-hoc payment amount.

**Fields**:
- `name`: **Visible to the customer on the checkout page.** Should be clear and descriptive (e.g., "Payment for Reservation #12345 - Guest John Doe", "Service Charge - Room Upgrade").
- `price_money`:
  - `amount`: **Integer amount in the smallest currency unit.** For example, for USD, $10.50 would be `1050`. For JPY, ¥1000 would be `1000`. This amount is typically fetched from the `reservation_payments.amount_due` or calculated based on the current outstanding balance of a reservation.
  - `currency`: The currency code (e.g., "USD", "JPY", "EUR"). This should be determined by the hotel's or system's configured currency.
- `location_id`: (Required) The ID of the Square location to associate this payment with. This should be a configurable setting within the PMS, allowing different properties or business units to use distinct Square locations.

#### order (Alternative/Future Enhancement)
While `quick_pay` is simpler for direct payment links, using an `order` based link allows for more detailed itemization (e.g., room charges, taxes, fees as separate line items), better tax handling by Square, and potentially more comprehensive tracking within Square's system.

If `order` is used, it would involve creating an `Order` object with `line_items` that reflect the reservation charges. This provides a more structured transaction.

For this initial conceptual design, `quick_pay` is the primary approach for its simplicity. `order` based links can be considered for future enhancements if detailed itemization on the Square checkout page itself is required.

#### checkout_options
- `allow_tipping`: `false` (Typically not applicable for reservation prepayments or standard service charges)
- `redirect_url`: The URL on the PMS to which the user is redirected after Square processes the payment (whether successful or failed). This page should provide clear feedback to the user about the payment status and next steps.
- `ask_for_shipping_address`: `false` (Shipping information is generally not required for reservation-related payments)
- `merchant_support_email`: (Optional) An email address that customers can use for support inquiries related to the payment
- `accepted_payment_methods`: (Optional) Allows specifying which payment methods are accepted. By default, Square usually enables card payments.

#### pre_populated_data (Optional but improves user experience)
- `buyer_email`: Pre-fill the client's email address from the PMS records
- `buyer_phone_number`: (Optional) Pre-fill the client's phone number from PMS records

#### payment_note (Crucial for reconciliation)
This is an internal note (not usually visible to the customer on the payment page) that will appear in Square transaction details and webhook payloads. Store a unique reference from the PMS, such as `reservation_payment_id` or a composite key like `reservation_id:payment_attempt_id` (e.g., `RES12345:PAYATTEMPT01`). This allows the PMS to reliably link a Square transaction back to the specific payment record it pertains to when processing webhooks or performing reconciliation.

### Storing Payment Links

#### Recommended Approach
Add columns to the existing `reservation_payments` table. This approach is generally simpler for managing payment link information directly associated with a payment record.

#### Proposed Columns for `reservation_payments` Table

- `square_payment_link_url` (TEXT, nullable): Stores the full URL of the generated Square payment link
- `square_link_id` (TEXT, nullable): Stores the unique ID of the payment link generated by Square (e.g., `pay_ln_xxxxxxxxxxxxxx`)
- `square_order_id` (TEXT, nullable): If the payment link was generated using an `order`, this field stores the corresponding Square Order ID
- `square_payment_link_status` (VARCHAR(50), nullable): Tracks the status of the link itself, *not the payment transaction*. Examples:
  - 'GENERATED': Link has been created
  - 'VIEWED': If Square provides information or if the PMS can infer that the link has been accessed
  - 'PAYMENT_ATTEMPTED': If the PMS can determine an attempt was made via this link before webhook confirmation
  - 'EXPIRED': If the link has an expiration date and has passed it
- `square_link_expires_at` (TIMESTAMP, nullable): Stores the expiration timestamp of the payment link, if provided by Square
- `idempotency_key_square_link` (VARCHAR(255), nullable): Stores the `idempotency_key` (e.g., UUID) that was used when calling Square's `CreatePaymentLink` API

### PMS Interface & Workflow

#### User Action
A button or action labeled something like "Generate Square Payment Link" or "Create Online Payment Link" available within the reservation's payment, billing, or folio section in the PMS interface.

#### Backend Process

1. **Request Initiation**: The PMS backend receives an internal request (e.g., from a staff user clicking the button) to generate a payment link for a specific reservation or `reservation_payment` record.

2. **Data Retrieval**: The backend fetches all necessary details for the payment, such as the outstanding balance from `reservation_payments.amount_due`, client's email from the `clients` table, reservation ID, and the relevant `location_id` for Square (from PMS configuration).

3. **Idempotency Key Generation**: The PMS generates a new, unique `idempotency_key` (e.g., a UUID) for the `CreatePaymentLink` API call to Square.

4. **Payload Construction**: The backend constructs the JSON payload for the Square `POST /v2/online-checkout/payment-links` endpoint, populating fields like `name`, `price_money` (amount and currency), `location_id`, `redirect_url`, `payment_note` (with `reservation_payment_id` or similar unique PMS reference), and the generated `idempotency_key`.

5. **API Call to Square**: The PMS backend makes a server-to-server API call to Square with the constructed payload and the Square API secret key for authentication.

6. **Response Handling (Success)**: If Square's API returns a successful response (e.g., HTTP 200 OK):
   - The PMS parses the response to extract the `url` (the payment link itself), `id` (the Square link ID), `order_id` (if an order was created), and any other relevant details like `expires_at`.
   - These details are then saved to the corresponding `reservation_payments` record in the PMS database (e.g., updating `square_payment_link_url`, `square_link_id`, `idempotency_key_square_link`, and setting `square_payment_link_status` to 'GENERATED').
   - The generated payment link URL is then returned to the PMS frontend.

7. **Frontend Display**: The PMS frontend displays the received payment link to the staff user. Options should be provided to easily copy the link or perhaps send it directly to the client via a pre-configured email template.

#### Error Handling
- If the API call to Square fails (e.g., network error, authentication issue, validation error in the payload):
  - The PMS backend should log the error details received from Square.
  - Provide clear and appropriate feedback to the staff user in the PMS interface (e.g., "Failed to generate payment link: [Square Error Message]").
- Implement retry mechanisms for transient network errors, using the same `idempotency_key` to prevent duplicate link creation.

## Handling Webhook Notifications

### Subscribed Events

#### Primary Event: payment.updated
This is a general event triggered for various changes to a payment object. The PMS will need to inspect the `status` field within the `payment` object in the event payload (e.g., `data.object.payment.status`) to determine if it has reached a terminal successful state, typically `COMPLETED`.

#### Alternative/Supplementary Events
- `invoice.payment_made`: If Square Invoices are used to send out payment links (or if invoices are paid through other means but need to reflect in the PMS), subscribing to this event would be relevant.

**Focus**: For this conceptual design, the primary focus is handling the `payment.updated` event to confirm payment success for links generated via `POST /v2/online-checkout/payment-links`.

### PMS Webhook Endpoint

**Path:** `POST /api/v1/webhooks/square`

**Accessibility:** This endpoint must be a publicly accessible HTTPS URL that Square's servers can reach.

**CSRF Exclusion:** If the PMS web application framework implements CSRF (Cross-Site Request Forgery) protection globally, this specific webhook endpoint route must be excluded. Square webhook notifications will not include CSRF tokens, and such protection would block legitimate requests from Square.

### Signature Verification (Crucial for Security)

This step is essential to ensure that incoming webhook notifications are genuinely from Square and have not been tampered with.

#### Process

1. **Retrieve Signature**: Get the value of the `X-Square-Signature` HTTP header from the incoming request.

2. **Get Raw Request Body**: Obtain the complete, unmodified raw request body as a UTF-8 string. It's important that the body is not parsed or altered before this step.

3. **Get Webhook Signing Secret**: Retrieve your Square Webhook Signing Secret. This secret is provided by Square in your Square Developer Dashboard. It must be stored securely (e.g., as an environment variable or in a secrets management system) and **NEVER** hardcoded into the application.

4. **Prepare String for Hashing**: Square generates its signature by concatenating your PMS webhook endpoint URL (the exact URL you configured in the Square Developer Dashboard for this notification) and the raw request body string from step 2.

5. **Calculate HMAC-SHA256 Hash**: Compute an HMAC-SHA256 hash of the concatenated string (from step 4), using your Webhook Signing Secret (from step 3) as the cryptographic key.

6. **Encode Hash**: Encode the resulting binary hash from step 5 into a Base64 string.

7. **Compare Signatures**: Compare the Base64 encoded hash you calculated (from step 6) with the `X-Square-Signature` retrieved from the header (from step 1). They must be an exact match.

#### Action on Mismatch
If the calculated signature does not match the one in the header:
- Respond immediately with an HTTP `400 Bad Request` or `401 Unauthorized` status code.
- Do **NOT** process the payload further.
- Log the failed signature verification attempt, including details like the source IP if available, for security monitoring.

### Processing the Webhook (after successful signature verification)

#### Acknowledge Quickly (Best Practice)
Upon successful signature verification, the PMS webhook endpoint should immediately send an HTTP `200 OK` response back to Square. This acknowledges receipt of the event. Square expects a timely response (within a few seconds); otherwise, it may consider the notification failed and attempt to resend it.

#### Extract Key Information from the Payload

- `event_id`: Square's unique ID for this specific event notification (e.g., `evt_xxxxxxxxxxxx`)
- `type`: The event type (e.g., "payment.updated")
- `data.object.payment`: This is the core payment object when `type` is `payment.updated`:
  - `id`: Square's unique ID for the payment transaction itself (e.g., `pay_xxxxxxxxxxxx`)
  - `status`: The current status of the payment (e.g., `COMPLETED`, `FAILED`, `CANCELED`, `PENDING`)
  - `amount_money.amount`: The actual amount paid, in the smallest currency unit
  - `amount_money.currency`: The currency of the payment
  - `order_id`: If the payment link was associated with a Square Order
  - `note`: **Critical field for reconciliation.** Should contain the unique PMS reference
  - `created_at`: Timestamp indicating when the payment was created/processed by Square
  - `card_details.status`: (If payment is by card) Can provide additional confirmation

#### Idempotency Check (Crucial for Reliability)
Before initiating any business logic (like updating the PMS database), check if this specific event has already been successfully processed.

Use the `event_id` from the webhook payload as the key for this check. This can be implemented by:
- Storing processed `event_id`s in a temporary cache (like Redis) with an expiration time
- Storing processed `event_id`s in a dedicated database table

If the event has already been processed, the system can skip further processing and still respond with `200 OK`.

#### Asynchronous Processing (Highly Recommended)

**Why**: Complex business logic (database updates, notifying other systems, sending emails) can take longer than Square's allowed timeout for webhook responses.

**How**:
1. After successful signature verification and the idempotency check, and after sending the `200 OK` response to Square:
2. Place the validated webhook payload (or the necessary extracted information) onto a message queue or into a background job processing system (e.g., Redis with Celery/Sidekiq, RabbitMQ, AWS SQS).
3. A separate background worker process (or pool of workers) will pick up tasks from this queue.
4. This worker then handles all the "heavy lifting":
   - Retrieving the relevant `reservation_payment` record from the PMS database using the `note` field from the webhook
   - Updating the payment status, `square_transaction_id`, paid amount, etc., in the PMS database
   - Triggering any subsequent actions within the PMS (e.g., updating reservation status, sending confirmation emails)

**Benefits**: Ensures the webhook endpoint remains highly responsive, reliable, and scalable. Reduces the risk of timeouts and problems caused by Square retries.

## Updating PMS Payment Records

This section outlines the logic executed by the PMS *after* a Square webhook notification has been successfully received, its signature verified, acknowledged with a `200 OK`, and its processing has commenced (ideally by an asynchronous background worker).

### Identifying Reservation/Payment Record in PMS

#### Primary Method (using `payment_note`)
The most reliable way to link a Square payment to a PMS record is by using the `note` field from the Square payment object within the webhook payload (e.g., `data.object.payment.note`).

This field should contain the unique PMS identifier (e.g., `reservation_payment_id`, or a composite key like `reservation_id:payment_attempt_id`) that was originally supplied in the `payment_note` when the Square payment link was created.

The PMS worker will use this identifier to directly query the `reservation_payments` table (or its equivalent) to find the corresponding record.

#### Secondary/Fallback Method (using `order_id`)
If the payment link was created with a Square `order_id` (and this `order_id` was stored in the PMS, e.g., in `reservation_payments.square_order_id`), and if the `note` field is unexpectedly missing or unusable, the `order_id` from the Square payment object can be used as an alternative lookup key.

#### Logging for Traceability
Upon successfully identifying the PMS payment record, log both the Square Payment ID and the internal PMS payment record ID. This is crucial for auditing and troubleshooting.

If a PMS record cannot be identified using any method, this must be logged as an error, and the webhook event data should be saved for manual investigation.

### Updating the `reservation_payments` Table

#### Condition for Processing
Primarily, proceed with updating the PMS payment record as 'Paid' only if the Square payment status is `COMPLETED` (i.e., `data.object.payment.status == 'COMPLETED'`).

Additionally, if card payment details are available, checking `data.object.payment.card_details.status == 'CAPTURED'` provides further confirmation.

If the Square payment status is different (e.g., `FAILED`, `CANCELED`, `PENDING`), this information should still be logged. The `reservation_payments.square_payment_status` field in the PMS should be updated to reflect Square's status.

#### Database Transaction
All database modifications (updates to `reservation_payments`, related `reservations` table, etc.) stemming from a single webhook event must be wrapped in a database transaction. This ensures atomicity – either all changes are committed, or none are, maintaining data integrity if an error occurs mid-process.

#### Fields to Update in `reservation_payments`

- `payment_status` (PMS's internal status): Update to the system's designated status for a successful payment (e.g., 'Paid', 'Completed', 'Settled')
- `square_transaction_id` (TEXT): Store the Square payment ID from `data.object.payment.id`
- `square_payment_status` (VARCHAR): Store the final status from Square (e.g., "COMPLETED")
- `paid_amount` (Numeric/Decimal): Store or confirm the `amount_money.amount` from the Square payment object
  - Remember this amount is in the smallest currency unit (e.g., cents). Convert it to the PMS's standard currency representation if necessary.
  - Compare this `paid_amount` with the `amount_due` or expected amount for the `reservation_payments` record. Log any discrepancies.
- `payment_date` (TIMESTAMP/DATETIME): Store the timestamp of the payment from `data.object.payment.created_at`
- `payment_method_details` (TEXT/JSON, Optional): Store any relevant, non-sensitive payment method details
- `updated_at` (TIMESTAMP/DATETIME): Update the record's own `updated_at` timestamp

#### Preventing Duplicate Updates (Application-Level Check)
While webhook ingestion should handle idempotency using `event_id`, an additional safety check within the worker is good practice before applying updates:
- Check if `square_transaction_id` is already populated with the current Square payment ID
- Or, check if the `payment_status` is already 'Paid' (or the equivalent terminal success status)
- If the payment appears to have already been processed to completion, log this and skip redundant updates

### Related Actions (Post-Payment Update)

Once the `reservation_payments` record is successfully updated within the database transaction, the following actions can be triggered:

#### Update Reservation Status
If the now-completed payment satisfies the conditions for confirming a reservation (e.g., full prepayment received, deposit paid), the overall status of the parent `reservations` record should be updated (e.g., from 'Pending Payment' or 'Hold' to 'Confirmed' or 'Guaranteed').

#### Notifications
- **Internal Notifications**: Trigger notifications to relevant PMS users (e.g., front desk, reservations department) about the successful payment and any change in reservation status
- **Client Notifications**: Consider sending a payment confirmation email/receipt to the client via the PMS's own notification system

#### Inventory/Availability Adjustments
For most PMS setups, inventory (e.g., room availability) is adjusted when a reservation is initially created or placed on a temporary hold. However, if payment confirmation is the absolute final step that secures a booking from a limited pool, ensure that this step correctly interfaces with inventory management if needed.

#### Financial Reconciliation / Reporting
The updated payment data (especially `square_transaction_id` and `paid_amount`) is critical for financial reconciliation processes against bank statements and Square settlement reports.

#### Logging
Maintain comprehensive logs of all actions taken by the worker, including the reservation ID, payment ID, amounts, status changes, and any notifications sent. Any errors or exceptions encountered during these post-payment update steps must be critically logged for investigation and potential manual intervention.

## Data Models and Database Schema Changes

### `reservation_payments` Table Modifications

The following new columns are proposed to be added to the `reservation_payments` table:

- `square_payment_link_url` (TEXT, nullable): Stores the full URL of the generated Square payment link
- `square_link_id` (VARCHAR(255), nullable): Stores the unique ID of the payment link object as assigned by Square
- `square_order_id` (VARCHAR(255), nullable): If the payment link was generated based on a Square Order
- `square_transaction_id` (VARCHAR(255), nullable, UNIQUE): Stores the unique transaction ID generated by Square upon successful completion
- `square_payment_status_detail` (VARCHAR(50), nullable): Stores the detailed status of the payment as reported by Square
- `idempotency_key_square_link` (VARCHAR(255), nullable): Stores the idempotency key used when creating the payment link
- `payment_method_source` (VARCHAR(50), default 'PMS'): Indicates the origin or system facilitating the payment

### (Optional) New Table: `square_webhook_events`

Creating a dedicated table to log all incoming webhook events from Square is highly recommended for robustness, auditing, and debugging.

#### Proposed Schema

- `id` (SERIAL or BIGSERIAL, Primary Key): Auto-incrementing primary key
- `square_event_id` (VARCHAR(255), NOT NULL, UNIQUE): The unique event ID from the Square webhook payload
- `event_type` (VARCHAR(255), NOT NULL): The type of event (e.g., `payment.updated`)
- `payload` (JSONB or TEXT, NOT NULL): The full JSON payload received from Square
- `status` (VARCHAR(50), NOT NULL, DEFAULT 'RECEIVED'): Tracks the PMS's processing status
  - `RECEIVED`: Initial status upon logging
  - `PROCESSING`: When a worker picks it up
  - `COMPLETED`: Successfully processed by the PMS
  - `ERROR`: An error occurred during processing
  - `IGNORED_DUPLICATE`: If the `square_event_id` was already logged
- `processing_notes` (TEXT, nullable): For storing any error messages or relevant notes
- `received_at` (TIMESTAMP WITH TIME ZONE, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Timestamp of when the webhook was received
- `processed_at` (TIMESTAMP WITH TIME ZONE, nullable): Timestamp of when the processing was completed

## Security Considerations

### API Credentials and Secrets Management

#### Types of Secrets
- **Square API Secret Key (Access Token)**: Authenticates the PMS's API requests to Square
- **Square Webhook Signing Secret**: Used to verify incoming webhook notifications

#### Secure Storage
- **NEVER hardcode secrets** directly in application source code or configuration files
- **Environment Variables**: At a minimum, store secrets in environment variables
- **Secrets Management Services (Recommended for Production)**: Use dedicated services like:
  - HashiCorp Vault
  - AWS Secrets Manager
  - Google Cloud Secret Manager
  - Azure Key Vault

#### Access Control
- Limit access to these secrets to the minimum necessary systems and personnel
- Apply the principle of least privilege for API keys

### Webhook Security

#### Signature Verification (Mandatory)
Every incoming webhook notification's `X-Square-Signature` header **must** be verified using the HMAC-SHA256 method with your Square Webhook Signing Secret. This is the primary defense against spoofed webhook events.

#### HTTPS Enforcement
The PMS webhook endpoint URL provided to Square must use HTTPS (SSL/TLS).

#### Replay Attack Prevention
Prevent replay attacks by logging the unique `event_id` from each webhook payload and ensuring that each `event_id` is processed only once.

#### Limited Endpoint Exposure (Defense in Depth)
Consider restricting network access to your webhook endpoint to only allow POST requests from Square's known IP addresses.

#### Respond Quickly
Acknowledge webhooks with a `200 OK` quickly and process them asynchronously to avoid timeouts.

### PCI Compliance

#### Square's Role (PCI DSS Scope Reduction)
By using Square's Online Checkout API (payment links), the payment card data is entered directly into Square's secure, PCI DSS validated environment. The PMS itself **does not** handle, process, transmit, or store this sensitive cardholder data.

#### PMS Responsibilities
The PMS application and its infrastructure are still in scope for PCI DSS concerning:
- Protecting any customer data it *does* handle
- Ensuring the integration with Square is implemented securely
- Maintaining overall secure network and system configurations
- Implementing secure development and operational practices

#### Attestation (SAQ)
The business will likely need to complete a PCI DSS Self-Assessment Questionnaire (SAQ). Given that all cardholder data functions are outsourced to Square, this is typically SAQ A.

### Idempotency

#### API Calls to Square
All mutating API requests (POST, PUT, DELETE) made from the PMS to Square should include an `Idempotency-Key` header. The PMS should generate a unique value (e.g., a UUID) for this key for each distinct operation.

#### Webhook Event Handling (PMS Side)
The PMS's webhook processing logic must be idempotent. If the PMS receives the same event notification multiple times, it should not result in duplicate actions.

### Input Validation and Sanitization

#### Data from Square (Webhooks)
While webhook data is generally trusted after successful signature verification, validate the structure, data types, and expected formats of fields within the payload before using them.

#### User Input (PMS Side)
Any data entered by users into the PMS that might eventually be used to construct API calls to Square must be rigorously validated and sanitized on the server-side.

### Logging and Monitoring

#### Comprehensive Audit Trails
- **API Requests**: Log all API requests sent to Square and the responses received
- **Webhook Events**: Log all incoming webhook events
- **Business Logic Actions**: Log key actions taken by the PMS based on these events

#### Error Monitoring and Alerting
Implement robust error tracking for all parts of the integration. Configure alerts for critical failures.

### Secure Development Practices
- Adhere to general secure coding principles (OWASP Top 10)
- Keep all system components and software dependencies up-to-date
- Regular security assessments or penetration testing

## Implementation Guidelines

The conceptual design outlined in this document describes the architecture and flow for integrating Square payment links. The actual implementation of these features must adhere to the specific coding standards, development guidelines, and best practices established for this project.

Developers should consult the project's `instructions.md` file for guidance on:
- Backend conventions
- Frontend UI/UX standards
- Error handling patterns
- Code commenting and style
- Project-specific development practices

## Related Documentation

- **[Payment Gateway Integration](payment-gateway-guide.md)** - General payment integration guide
- **[Integration Patterns](../../architecture/integration-patterns.md)** - External system integration approaches
- **[API Security](../../api/authentication.md)** - API authentication and security
- **[Webhook Handling](../../backend/webhook-handling.md)** - Webhook processing patterns

---

*This integration design ensures secure, reliable, and PCI-compliant payment processing through Square's platform.*
