# Square Payment Integration Conceptual Design

This document outlines the conceptual design for integrating Square's payment link functionality with the Property Management System (PMS).

## 1. Generating Square Payment Links

### 1.1. API Call to Square
- **Endpoint:** `POST /v2/online-checkout/payment-links` (Confirmed as appropriate for creating payment links).
- **Authentication:** Bearer token using the Square API secret key. This key must be securely stored and managed.
- **Key Request Payload Fields:**
  - `idempotency_key`: (Required) A unique string (e.g., UUID generated by the PMS) that identifies this `CreatePaymentLink` request. Square uses this to prevent processing the same request multiple times if there are network issues or retries. Importance: Ensures a payment link is not accidentally created multiple times for the same payment intent.
  - `description`: (Optional but recommended) A brief description of the payment link, visible to the merchant in the Square dashboard (e.g., "Reservation #12345 - Initial Payment"). Not typically shown to the customer on the payment page.
  - `quick_pay`: (Primary method for this design) For creating a link for a single, ad-hoc payment amount.
    - `name`: **Visible to the customer on the checkout page.** Should be clear and descriptive (e.g., "Payment for Reservation #12345 - Guest John Doe", "Service Charge - Room Upgrade").
    - `price_money`:
      - `amount`: **Integer amount in the smallest currency unit.** For example, for USD, $10.50 would be `1050`. For JPY, ¥1000 would be `1000`. This amount is typically fetched from the `reservation_payments.amount_due` or calculated based on the current outstanding balance of a reservation.
      - `currency`: The currency code (e.g., "USD", "JPY", "EUR"). This should be determined by the hotel's or system's configured currency.
    - `location_id`: (Required) The ID of the Square location to associate this payment with. This should be a configurable setting within the PMS, allowing different properties or business units to use distinct Square locations.
  - `order`: (Alternative/Future Enhancement) While `quick_pay` is simpler for direct payment links, using an `order` based link allows for more detailed itemization (e.g., room charges, taxes, fees as separate line items), better tax handling by Square, and potentially more comprehensive tracking within Square's system.
    - If `order` is used, it would involve creating an `Order` object with `line_items` that reflect the reservation charges. This provides a more structured transaction.
    - For this initial conceptual design, `quick_pay` is the primary approach for its simplicity. `order` based links can be considered for future enhancements if detailed itemization on the Square checkout page itself is required.
  - `checkout_options`:
    - `allow_tipping`: `false` (Typically not applicable for reservation prepayments or standard service charges).
    - `redirect_url`: The URL on the PMS to which the user is redirected after Square processes the payment (whether successful or failed). This page should provide clear feedback to the user about the payment status and next steps.
    - `ask_for_shipping_address`: `false` (Shipping information is generally not required for reservation-related payments).
    - `merchant_support_email`: (Optional) An email address that customers can use for support inquiries related to the payment. Could be a general support email for the property.
    - `accepted_payment_methods`: (Optional) Allows specifying which payment methods are accepted. By default, Square usually enables card payments. Can be configured to include/exclude methods like `afterpay_clearpay`, `cash_app_pay` if these are relevant and enabled in the Square account. For most reservation systems, standard card acceptance is the primary need.
  - `pre_populated_data`: (Optional but improves user experience)
    - `buyer_email`: Pre-fill the client's email address from the PMS records.
    - `buyer_phone_number`: (Optional) Pre-fill the client's phone number from PMS records.
  - `payment_note`: **Crucial for reconciliation.** This is an internal note (not usually visible to the customer on the payment page) that will appear in Square transaction details and webhook payloads. Store a unique reference from the PMS, such as `reservation_payment_id` or a composite key like `reservation_id:payment_attempt_id` (e.g., `RES12345:PAYATTEMPT01`). This allows the PMS to reliably link a Square transaction back to the specific payment record it pertains to when processing webhooks or performing reconciliation.

### 1.2. Storing Payment Links
- **Recommendation:** For this conceptual design, it's recommended to add columns to the existing `reservation_payments` table. This approach is generally simpler for managing payment link information directly associated with a payment record, unless there's a compelling reason for a separate table (e.g., if a single payment attempt could have multiple distinct links, or if the lifecycle of the link itself requires very complex status tracking independent of the payment).
- **Proposed Columns for `reservation_payments` Table:**
  - `square_payment_link_url` (TEXT, nullable): Stores the full URL of the generated Square payment link.
  - `square_link_id` (TEXT, nullable): Stores the unique ID of the payment link generated by Square (e.g., `pay_ln_xxxxxxxxxxxxxx`). This is useful for direct API lookups of the link if needed.
  - `square_order_id` (TEXT, nullable): If the payment link was generated using an `order` (see section 1.1), this field stores the corresponding Square Order ID.
  - `square_payment_link_status` (VARCHAR(50), nullable): Tracks the status of the link itself, *not the payment transaction*. Examples:
    - 'GENERATED': Link has been created.
    - 'VIEWED': If Square provides information or if the PMS can infer that the link has been accessed (potentially a future enhancement).
    - 'PAYMENT_ATTEMPTED': If the PMS can determine an attempt was made via this link before webhook confirmation.
    - 'EXPIRED': If the link has an expiration date and has passed it.
  - `square_link_expires_at` (TIMESTAMP, nullable): Stores the expiration timestamp of the payment link, if provided by Square. Some links can be configured to expire.
  - `idempotency_key_square_link` (VARCHAR(255), nullable): Stores the `idempotency_key` (e.g., UUID) that was used when calling Square's `CreatePaymentLink` API. This is useful for auditing and troubleshooting.

### 1.3. PMS Interface & Workflow
- **User Action:** A button or action labeled something like "Generate Square Payment Link" or "Create Online Payment Link" available within the reservation's payment, billing, or folio section in the PMS interface.
- **Backend Process:**
    1. **Request Initiation:** The PMS backend receives an internal request (e.g., from a staff user clicking the button) to generate a payment link for a specific reservation or `reservation_payment` record.
    2. **Data Retrieval:** The backend fetches all necessary details for the payment, such as the outstanding balance from `reservation_payments.amount_due`, client's email from the `clients` table, reservation ID, and the relevant `location_id` for Square (from PMS configuration).
    3. **Idempotency Key Generation:** The PMS generates a new, unique `idempotency_key` (e.g., a UUID) for the `CreatePaymentLink` API call to Square.
    4. **Payload Construction:** The backend constructs the JSON payload for the Square `POST /v2/online-checkout/payment-links` endpoint, populating fields like `name`, `price_money` (amount and currency), `location_id`, `redirect_url`, `payment_note` (with `reservation_payment_id` or similar unique PMS reference), and the generated `idempotency_key`.
    5. **API Call to Square:** The PMS backend makes a server-to-server API call to Square with the constructed payload and the Square API secret key for authentication.
    6. **Response Handling (Success):** If Square's API returns a successful response (e.g., HTTP 200 OK):
        - The PMS parses the response to extract the `url` (the payment link itself), `id` (the Square link ID), `order_id` (if an order was created), and any other relevant details like `expires_at`.
        - These details are then saved to the corresponding `reservation_payments` record in the PMS database (e.g., updating `square_payment_link_url`, `square_link_id`, `idempotency_key_square_link`, and setting `square_payment_link_status` to 'GENERATED').
        - The generated payment link URL is then returned to the PMS frontend.
    7. **Frontend Display:** The PMS frontend displays the received payment link to the staff user. Options should be provided to easily copy the link or perhaps send it directly to the client via a pre-configured email template.
- **Error Handling:**
    - If the API call to Square fails (e.g., network error, authentication issue, validation error in the payload):
        - The PMS backend should log the error details received from Square.
        - Provide clear and appropriate feedback to the staff user in the PMS interface (e.g., "Failed to generate payment link: [Square Error Message]").
    - Implement retry mechanisms for transient network errors, using the same `idempotency_key` to prevent duplicate link creation.

## 2. Handling Webhook Notifications

### 2.1. Subscribed Events
- **Primary Event:** `payment.updated`. This is a general event triggered for various changes to a payment object. The PMS will need to inspect the `status` field within the `payment` object in the event payload (e.g., `data.object.payment.status`) to determine if it has reached a terminal successful state, typically `COMPLETED`.
- **Alternative/Supplementary Events:**
    - `invoice.payment_made`: If Square Invoices are used to send out payment links (or if invoices are paid through other means but need to reflect in the PMS), subscribing to this event would be relevant. For the current design focusing on direct Payment Links API, `payment.updated` is more direct.
    - Research indicates that `payment.updated` is the standard and most encompassing event for tracking the status of payments created via the Online Checkout API (payment links). While events like `checkout.session.completed` might exist in other contexts (like Square Online Store), for API-generated payment links, `payment.updated` is the key event to monitor for successful payment capture.
- **Focus:** For this conceptual design, the primary focus is handling the `payment.updated` event to confirm payment success for links generated via `POST /v2/online-checkout/payment-links`.

### 2.2. PMS Webhook Endpoint
- **Path:** `POST /api/v1/webhooks/square` (Using a versioned API path like `/api/v1/` is good practice for future iterations).
- **Accessibility:** This endpoint must be a publicly accessible HTTPS URL that Square's servers can reach.
- **CSRF Exclusion:** If the PMS web application framework implements CSRF (Cross-Site Request Forgery) protection globally, this specific webhook endpoint route must be excluded. Square webhook notifications will not include CSRF tokens, and such protection would block legitimate requests from Square.

### 2.3. Signature Verification (Crucial for Security)
- This step is essential to ensure that incoming webhook notifications are genuinely from Square and have not been tampered with.
- **Process:**
    1. **Retrieve Signature:** Get the value of the `X-Square-Signature` HTTP header from the incoming request.
    2. **Get Raw Request Body:** Obtain the complete, unmodified raw request body as a UTF-8 string. It's important that the body is not parsed or altered before this step.
    3. **Get Webhook Signing Secret:** Retrieve your Square Webhook Signing Secret. This secret is provided by Square in your Square Developer Dashboard. It must be stored securely (e.g., as an environment variable or in a secrets management system) and **NEVER** hardcoded into the application.
    4. **Prepare String for Hashing:** Square generates its signature by concatenating your PMS webhook endpoint URL (the exact URL you configured in the Square Developer Dashboard for this notification) and the raw request body string from step 2.
    5. **Calculate HMAC-SHA256 Hash:** Compute an HMAC-SHA256 hash of the concatenated string (from step 4), using your Webhook Signing Secret (from step 3) as the cryptographic key.
    6. **Encode Hash:** Encode the resulting binary hash from step 5 into a Base64 string.
    7. **Compare Signatures:** Compare the Base64 encoded hash you calculated (from step 6) with the `X-Square-Signature` retrieved from the header (from step 1). They must be an exact match.
- **Action on Mismatch:** If the calculated signature does not match the one in the header:
    - Respond immediately with an HTTP `400 Bad Request` or `401 Unauthorized` status code.
    - Do **NOT** process the payload further.
    - Log the failed signature verification attempt, including details like the source IP if available, for security monitoring.

### 2.4. Processing the Webhook (after successful signature verification)
- **Acknowledge Quickly (Best Practice):**
    - Upon successful signature verification, the PMS webhook endpoint should immediately send an HTTP `200 OK` response back to Square.
    - This acknowledges receipt of the event. Square expects a timely response (within a few seconds); otherwise, it may consider the notification failed and attempt to resend it, potentially leading to duplicate processing if not handled carefully.
- **Extract Key Information from the Payload:**
    - `event_id` (Square's unique ID for this specific event notification, e.g., `evt_xxxxxxxxxxxx` from the outer layer of the JSON payload, often `id` at the root of the event). Useful for logging and idempotency.
    - `type` (The event type, e.g., "payment.updated"). Verify this matches expected types.
    - `data.object.payment` (This is the core payment object when `type` is `payment.updated`):
        - `id`: Square's unique ID for the payment transaction itself (e.g., `pay_xxxxxxxxxxxx`). This should be stored in the PMS as `square_transaction_id`.
        - `status`: The current status of the payment (e.g., `COMPLETED`, `FAILED`, `CANCELED`, `PENDING`). The PMS should typically only consider `COMPLETED` as a successful payment for fulfillment purposes.
        - `amount_money.amount`: The actual amount paid, in the smallest currency unit.
        - `amount_money.currency`: The currency of the payment.
        - `order_id`: If the payment link was associated with a Square Order, this field will contain the `order_id`.
        - `note`: **This is a critical field for reconciliation.** It should contain the unique PMS reference (e.g., `reservation_payment_id` or `reservation_id:payment_attempt_id`) that was originally provided in the `payment_note` field during the payment link creation.
        - `created_at`: Timestamp indicating when the payment was created/processed by Square.
        - `card_details.status`: (If payment is by card) Can provide additional confirmation, e.g., `CAPTURED` indicates the funds have been captured. Other statuses might include `AUTHORIZED`, `FAILED`.
- **Idempotency Check (Crucial for Reliability):**
    - Before initiating any business logic (like updating the PMS database), check if this specific event has already been successfully processed.
    - Use the `event_id` from the webhook payload as the key for this check.
    - This can be implemented by:
        - Storing processed `event_id`s in a temporary cache (like Redis) with an expiration time.
        - Storing processed `event_id`s in a dedicated database table.
    - If the event has already been processed, the system can skip further processing and still respond with `200 OK` (as the event was valid and previously handled). This prevents issues from Square's webhook retries.
- **Asynchronous Processing (Highly Recommended):**
    - **Why:** Complex business logic (database updates, notifying other systems, sending emails) can take longer than Square's allowed timeout for webhook responses. Performing these tasks synchronously within the webhook request handler can lead to timeouts and unnecessary retries from Square.
    - **How:**
        1. After successful signature verification and the idempotency check, and after sending the `200 OK` response to Square:
        2. Place the validated webhook payload (or the necessary extracted information) onto a message queue or into a background job processing system (e.g., Redis with Celery/Sidekiq, RabbitMQ, AWS SQS).
        3. A separate background worker process (or pool of workers) will pick up tasks from this queue.
        4. This worker then handles all the "heavy lifting":
            - Retrieving the relevant `reservation_payment` record from the PMS database using the `note` field from the webhook.
            - Updating the payment status, `square_transaction_id`, paid amount, etc., in the PMS database (as detailed in Section 3).
            - Triggering any subsequent actions within the PMS (e.g., updating reservation status, sending confirmation emails).
    - **Benefits:** Ensures the webhook endpoint remains highly responsive, reliable, and scalable. Reduces the risk of timeouts and problems caused by Square retries.

## 3. Updating PMS Payment Records

This section outlines the logic executed by the PMS *after* a Square webhook notification has been successfully received, its signature verified, acknowledged with a `200 OK`, and its processing has commenced (ideally by an asynchronous background worker, as described in Section 2.4).

### 3.1. Identifying Reservation/Payment Record in PMS
- **Primary Method (using `payment_note`):**
    - The most reliable way to link a Square payment to a PMS record is by using the `note` field from the Square payment object within the webhook payload (e.g., `data.object.payment.note`).
    - This field should contain the unique PMS identifier (e.g., `reservation_payment_id`, or a composite key like `reservation_id:payment_attempt_id`) that was originally supplied in the `payment_note` when the Square payment link was created (see Section 1.1).
    - The PMS worker will use this identifier to directly query the `reservation_payments` table (or its equivalent) to find the corresponding record.
- **Secondary/Fallback Method (using `order_id`):**
    - If the payment link was created with a Square `order_id` (and this `order_id` was stored in the PMS, e.g., in `reservation_payments.square_order_id`), and if the `note` field is unexpectedly missing or unusable, the `order_id` from the Square payment object (e.g., `data.object.payment.order_id`) can be used as an alternative lookup key.
- **Logging for Traceability:**
    - Upon successfully identifying the PMS payment record, log both the Square Payment ID (from `data.object.payment.id`) and the internal PMS payment record ID (e.g., `reservation_payments.id`) that it maps to. This is crucial for auditing and troubleshooting.
    - If a PMS record cannot be identified using any method, this must be logged as an error, and the webhook event data should be saved for manual investigation.

### 3.2. Updating the `reservation_payments` Table
- **Condition for Processing:**
    - Primarily, proceed with updating the PMS payment record as 'Paid' only if the Square payment status is `COMPLETED` (i.e., `data.object.payment.status == 'COMPLETED'`).
    - Additionally, if card payment details are available, checking `data.object.payment.card_details.status == 'CAPTURED'` provides further confirmation.
    - If the Square payment status is different (e.g., `FAILED`, `CANCELED`, `PENDING`), this information should still be logged. The `reservation_payments.square_payment_status` field in the PMS should be updated to reflect Square's status. For `FAILED` or `CANCELED` payments, the PMS might trigger alerts or specific workflows.
- **Database Transaction:**
    - All database modifications (updates to `reservation_payments`, related `reservations` table, etc.) stemming from a single webhook event must be wrapped in a database transaction. This ensures atomicity – either all changes are committed, or none are, maintaining data integrity if an error occurs mid-process.
- **Fields to Update in `reservation_payments`:**
    - `payment_status` (PMS's internal status): Update to the system's designated status for a successful payment (e.g., 'Paid', 'Completed', 'Settled').
    - `square_transaction_id` (TEXT): Store the Square payment ID from `data.object.payment.id`. This is the definitive link to the Square transaction.
    - `square_payment_status` (VARCHAR): Store the final status from Square, e.g., `data.object.payment.status` (which should be "COMPLETED").
    - `paid_amount` (Numeric/Decimal): Store or confirm the `amount_money.amount` from the Square payment object.
        - Remember this amount is in the smallest currency unit (e.g., cents). Convert it to the PMS's standard currency representation if necessary.
        - It's crucial to compare this `paid_amount` with the `amount_due` or expected amount for the `reservation_payments` record. Log any discrepancies (e.g., overpayment or underpayment) for review. Handle discrepancies according to business rules.
    - `payment_date` (TIMESTAMP/DATETIME): Store the timestamp of the payment. `data.object.payment.created_at` (or `updated_at` if it reflects the completion time, or a specific `captured_at` field if available) from the Square payment object is typically used.
    - `payment_method_details` (TEXT/JSON, Optional): Store any relevant, non-sensitive payment method details provided in the webhook, if deemed necessary for reporting or customer service. For Square Payment Links, this might include card brand or payment source type if available. Avoid storing sensitive data; Square's tokenization handles PCI compliance.
    - `updated_at` (TIMESTAMP/DATETIME): Update the record's own `updated_at` timestamp.
- **Preventing Duplicate Updates (Application-Level Check):**
    - While webhook ingestion should handle idempotency using `event_id` (Section 2.4), an additional safety check within the worker is good practice before applying updates:
        - Check if `square_transaction_id` is already populated with the current Square payment ID.
        - Or, check if the `payment_status` is already 'Paid' (or the equivalent terminal success status).
        - If the payment appears to have already been processed to completion, log this and skip redundant updates to prevent issues like double crediting a reservation.

### 3.3. Related Actions (Post-Payment Update)
- Once the `reservation_payments` record is successfully updated within the database transaction, the following actions can be triggered (ideally, these could also be managed via an event-driven system within the PMS):
- **Update Reservation Status:**
    - If the now-completed payment satisfies the conditions for confirming a reservation (e.g., full prepayment received, deposit paid), the overall status of the parent `reservations` record should be updated (e.g., from 'Pending Payment' or 'Hold' to 'Confirmed' or 'Guaranteed'). This logic is specific to the PMS's business rules.
- **Notifications:**
    - **Internal Notifications:** Trigger notifications to relevant PMS users (e.g., front desk, reservations department) about the successful payment and any change in reservation status. This could be via an internal dashboard, email, or other alerting mechanism.
    - **Client Notifications:** Consider sending a payment confirmation email/receipt to the client via the PMS's own notification system. This is often preferred for consistent branding, even if Square also sends a receipt. Ensure this is configurable.
- **Inventory/Availability Adjustments:**
    - For most PMS setups, inventory (e.g., room availability) is adjusted when a reservation is initially created or placed on a temporary hold.
    - However, if payment confirmation is the absolute final step that secures a booking from a limited pool (especially if payment links have a longer expiry), ensure that this step correctly interfaces with inventory management if needed. Typically, this is less of an issue if the reservation already provisionally holds inventory.
- **Financial Reconciliation / Reporting:**
    - The updated payment data (especially `square_transaction_id` and `paid_amount`) is critical for financial reconciliation processes against bank statements and Square settlement reports. Ensure data is structured to support this.
- **Logging:**
    - Maintain comprehensive logs of all actions taken by the worker, including the reservation ID, payment ID, amounts, status changes, and any notifications sent.
    - Any errors or exceptions encountered during these post-payment update steps must be critically logged for investigation and potential manual intervention.

## 4. Data Models and Database Schema Changes

This section details the proposed modifications to the PMS database schema to support the Square payment link integration.

### 4.1. `reservation_payments` Table Modifications
It is recommended to modify the existing `reservation_payments` table (or its equivalent in the PMS) to store Square-specific payment link and transaction data. This approach keeps all payment-related information centralized within a single record, simplifying data retrieval and management for a given payment.

The following new columns are proposed to be added to the `reservation_payments` table:

- `square_payment_link_url` (TEXT, nullable):
  - **Description:** Stores the full URL of the generated Square payment link that was provided to the client for this specific payment record.
  - **Example:** `https://connect.squareup.com/v2/online-checkout/payment-links/pl_xxxxxxxxxxxx`

- `square_link_id` (VARCHAR(255), nullable):
  - **Description:** Stores the unique ID of the payment link object as assigned by Square (e.g., the `id` field in the `CreatePaymentLink` response, often prefixed with `pl_`).
  - **Purpose:** Useful for any future direct API interactions with the payment link itself (e.g., retrieving its status directly from Square, if such functionality is used).
  - **Index:** Consider adding an index if lookups by `square_link_id` are anticipated.

- `square_order_id` (VARCHAR(255), nullable):
  - **Description:** If the payment link was generated based on a Square Order (rather than a `quick_pay` ad-hoc amount), this field stores the unique ID of that Square Order.
  - **Purpose:** Important for reconciliation and tracking if using Square Order-based payment links, allowing correlation with order details in the Square dashboard.

- `square_transaction_id` (VARCHAR(255), nullable, UNIQUE):
  - **Description:** Stores the unique transaction ID generated by Square upon successful completion and capture of the payment (e.g., `id` from the `Payment` object in the webhook, often prefixed like `pay_xxxxxxxx`, `sq_trx_xxxxxxxx`, or similar).
  - **Purpose:** This is the primary key for the transaction on Square's side. Making this column `UNIQUE` in the database provides an additional layer of protection against processing the same successful payment webhook event multiple times at the database level.
  - **Index:** A unique index will be automatically created if `UNIQUE` constraint is applied. If not unique, an index is highly recommended for fast lookups during webhook processing or reconciliation.

- `square_payment_status_detail` (VARCHAR(50), nullable):
  - **Description:** Stores the detailed status of the payment as reported by Square via webhook (e.g., `COMPLETED`, `FAILED`, `PENDING`, `CANCELED`, `AUTHORIZED`).
  - **Purpose:** Provides more granular insight into the payment's state on Square's platform, supplementing the main PMS payment status (which might be more generic like 'Paid' or 'Failed').

- `idempotency_key_square_link` (VARCHAR(255), nullable):
  - **Description:** Stores the idempotency key (e.g., UUID) that was generated by the PMS and sent to Square when the `CreatePaymentLink` API call was made.
  - **Purpose:** Primarily for logging, auditing, and troubleshooting. It helps trace the request made to Square if issues arise with link creation.

- `payment_method_source` (VARCHAR(50), default 'PMS'):
  - **Description:** This column should be added or modified to indicate the origin or system facilitating the payment. For payments processed via this Square integration, its value would be updated to 'Square'.
  - **Purpose:** Helps differentiate payments made via Square from those manually entered into the PMS, processed by other payment gateways, or other sources. If the column already exists with a different name but similar purpose, adapt as needed. The default 'PMS' could signify a manually recorded payment.

### 4.2. (Optional) New Table: `square_webhook_events`
While not strictly required for the basic functionality, creating a dedicated table to log all incoming webhook events from Square is highly recommended for robustness, auditing, and debugging.

- **Justification:**
    - **Troubleshooting:** Essential for diagnosing issues with webhook processing. If a payment isn't updated correctly in the PMS, this table provides the first point of investigation to see what data was received from Square and when.
    - **Audit Trail:** Offers a clear audit trail of all notifications received from Square.
    - **Reprocessing (with caution):** In some failure scenarios (e.g., a temporary bug in the PMS worker logic), it might be possible to manually trigger reprocessing of an event from this logged payload, *after* fixing the underlying issue. This must be done with extreme caution to avoid unintended side effects.
    - **Understanding Event Flow:** Helps in understanding the sequence and types of events Square sends.

- **Proposed Schema for `square_webhook_events`:**
  - `id` (SERIAL or BIGSERIAL, Primary Key): Auto-incrementing primary key.
  - `square_event_id` (VARCHAR(255), NOT NULL, UNIQUE): The unique event ID from the Square webhook payload (e.g., `evt_xxxxxxxxxxxx`). Adding a `UNIQUE` constraint ensures that the same event notification from Square (due to retries) is not logged multiple times if the webhook handler checks for existence before inserting.
  - `event_type` (VARCHAR(255), NOT NULL): The type of event (e.g., `payment.updated`, `invoice.payment_made`).
  - `payload` (JSONB or TEXT, NOT NULL): The full JSON payload received from Square. `JSONB` is preferred if using PostgreSQL for its querying capabilities.
  - `status` (VARCHAR(50), NOT NULL, DEFAULT 'RECEIVED'): Tracks the PMS's processing status of this event. Examples:
    - `RECEIVED`: Initial status upon logging.
    - `PROCESSING`: When a worker picks it up.
    - `COMPLETED`: Successfully processed by the PMS.
    - `ERROR`: An error occurred during processing.
    - `IGNORED_DUPLICATE`: If the `square_event_id` was already logged.
  - `processing_notes` (TEXT, nullable): For storing any error messages, stack traces, or relevant notes from the PMS's attempt to process this event.
  - `received_at` (TIMESTAMP WITH TIME ZONE, NOT NULL, DEFAULT CURRENT_TIMESTAMP): Timestamp of when the webhook was received by the PMS.
  - `processed_at` (TIMESTAMP WITH TIME ZONE, nullable): Timestamp of when the processing by the PMS worker was completed (successfully or with an error).

- **Indexing:**
  - On `square_webhook_events`: A unique index on `square_event_id` is critical. Consider an index on `event_type` and `status` if these are frequently queried.

## 5. Security Considerations

Implementing a payment integration requires careful attention to security to protect sensitive data, ensure system integrity, and maintain trust.

### 5.1. API Credentials and Secrets Management
- **Types of Secrets:**
    - **Square API Secret Key (Access Token):** This key authenticates the PMS's API requests to Square (e.g., for creating payment links). It is highly sensitive.
    - **Square Webhook Signing Secret:** This secret is used by the PMS to verify that incoming webhook notifications are genuinely from Square and have not been tampered with.
- **Secure Storage:**
    - **NEVER hardcode secrets** directly in application source code, configuration files that are checked into version control, or client-side code.
    - **Environment Variables:** At a minimum, store secrets in environment variables that are loaded by the application at runtime. This is a common practice for many hosting environments.
    - **Secrets Management Services (Recommended for Production):** For enhanced security, especially in production environments, use a dedicated secrets management service. Examples include:
        - HashiCorp Vault
        - AWS Secrets Manager
        - Google Cloud Secret Manager
        - Azure Key Vault
      These services provide centralized management, auditing, strict access control, and often automatic rotation of secrets.
- **Access Control:**
    - Limit access to these secrets to the minimum necessary systems and personnel.
    - Apply the principle of least privilege for API keys if Square offers scoped permissions (ensure the key only has permissions for the required API endpoints, e.g., Payment Links, Webhooks, Payments).

### 5.2. Webhook Security
- **Signature Verification (Mandatory):**
    - As detailed in Section 2.3, **every** incoming webhook notification's `X-Square-Signature` header **must** be verified using the HMAC-SHA256 method with your Square Webhook Signing Secret.
    - This is the primary defense against spoofed webhook events from malicious actors. Reject any request that fails signature verification.
- **HTTPS Enforcement:**
    - The PMS webhook endpoint URL provided to Square must use HTTPS (SSL/TLS). This encrypts the webhook data in transit between Square and the PMS, protecting it from eavesdropping.
- **Replay Attack Prevention:**
    - Signature verification confirms authenticity and integrity, but an attacker could potentially capture a valid webhook and resend it (replay attack).
    - Prevent this by logging the unique `event_id` from each webhook payload (as proposed in Section 4.2 or through other means) and ensuring that each `event_id` is processed only once. This ties directly into the idempotent design of webhook handling (see Section 5.4 and 2.4). If an event with a previously processed `event_id` is received, it should be acknowledged with a `200 OK` but not re-processed.
- **Limited Endpoint Exposure (Defense in Depth):**
    - If feasible and practical, consider restricting network access to your webhook endpoint to only allow POST requests from Square's known IP addresses. Square publishes these IP addresses in their documentation.
    - **Caution:** IP addresses can change, sometimes with little notice. This should be viewed as a secondary, defense-in-depth measure, not a replacement for signature verification. If used, there must be a process to keep the IP whitelist updated.
- **Respond Quickly:** Acknowledge webhooks with a `200 OK` quickly and process them asynchronously to avoid timeouts that might cause Square to resend the webhook, increasing the window for certain issues.

### 5.3. PCI Compliance
- **Square's Role (PCI DSS Scope Reduction):**
    - By using Square's Online Checkout API (payment links), the payment card data (Cardholder Name, Primary Account Number (PAN), Expiration Date, CVV) is entered directly into Square's secure, PCI DSS validated environment.
    - The PMS itself **does not** handle, process, transmit, or store this sensitive cardholder data. This significantly reduces the PCI DSS compliance scope for the business operating the PMS.
- **PMS Responsibilities:**
    - The PMS application and its infrastructure are still in scope for PCI DSS concerning other aspects, such as:
        - Protecting any customer data it *does* handle (names, emails, contact information, reservation details).
        - Ensuring the integration with Square is implemented securely according to Square's documentation and best practices.
        - Maintaining overall secure network and system configurations.
        - Implementing secure development and operational practices.
- **Attestation (SAQ):**
    - The business will likely need to complete a PCI DSS Self-Assessment Questionnaire (SAQ). Given that all cardholder data functions are outsourced to Square (a validated third-party service provider), this is typically SAQ A. Consult with a Qualified Security Assessor (QSA) if unsure.

### 5.4. Idempotency
- **API Calls to Square (e.g., `CreatePaymentLink`):**
    - All mutating API requests (POST, PUT, DELETE) made from the PMS to Square should include an `Idempotency-Key` header.
    - The PMS should generate a unique value (e.g., a UUID) for this key for each distinct operation.
    - If Square receives a request with an idempotency key it has already processed successfully within a certain timeframe, it will return the original successful response without performing the operation again. This allows for safe retries of API calls in case of network errors or timeouts.
- **Webhook Event Handling (PMS Side):**
    - As mentioned in Section 2.4 and 5.2, the PMS's webhook processing logic must be idempotent.
    - This means if the PMS receives the same event notification (identified by `event_id` from Square) multiple times, it should not result in duplicate actions (e.g., updating a payment status multiple times, sending multiple confirmation emails for the same event, or incorrectly crediting a reservation balance twice).
    - This is typically achieved by:
        1. Logging processed `event_id`s.
        2. Before processing an event, checking if its `event_id` has already been logged as successfully processed.
        3. Alternatively, for payment completion events, checking if the `square_transaction_id` from the event is already recorded against the PMS payment record and marked as complete.

### 5.5. Input Validation and Sanitization
- **Data from Square (Webhooks):**
    - While webhook data is generally trusted after successful signature verification, it's good practice to validate the structure, data types, and expected formats of fields within the payload before using them in business logic or database operations. For example, ensure an amount is a valid integer, a status field contains an expected value, etc.
- **User Input (PMS Side):**
    - Any data entered by users into the PMS that might eventually be used to construct API calls to Square (e.g., payment amounts, descriptions, customer emails) must be rigorously validated and sanitized on the server-side.
    - This helps prevent issues like:
        - Injection attacks (e.g., XSS if data is reflected in UI, or other forms if data is passed to backend systems improperly).
        - Unexpected errors or malformed requests to Square due to invalid characters or data types.

### 5.6. Logging and Monitoring
- **Comprehensive Audit Trails:**
    - **API Requests:** Log all API requests sent to Square and the responses received (especially for `CreatePaymentLink`). Be mindful not to log the full API secret key.
    - **Webhook Events:** Log all incoming webhook events. Storing the full payload (as suggested in Section 4.2 for the `square_webhook_events` table) is invaluable for debugging. Redact or avoid logging any particularly sensitive information if it's not needed for operational purposes.
    - **Business Logic Actions:** Log key actions taken by the PMS based on these events (e.g., "Payment P123 updated to Paid for Reservation R456 based on Square transaction T789").
- **Error Monitoring and Alerting:**
    - Implement robust error tracking for all parts of the integration (API calls, webhook signature verification, webhook processing logic, database updates).
    - Configure alerts for critical failures (e.g., repeated API errors, high rate of webhook signature failures, failures in payment update logic) to enable quick investigation and resolution.

### 5.7. Secure Development Practices
- **General Secure Coding:** Adhere to general secure coding principles and practices, such as those outlined in the OWASP Top 10, for the development of the PMS application itself.
- **Dependency Management:**
    - Keep all system components and software dependencies up-to-date. This includes:
        - Operating System
        - Web server software (e.g., Nginx, Apache)
        - Backend programming language runtime and framework (e.g., Python/Django, Node.js/Express)
        - Any Square SDKs or client libraries used.
    - Regularly scan for vulnerabilities in dependencies and apply patches promptly.
- **Regular Security Assessments:** Consider periodic security assessments or penetration testing of the PMS application and its integration points.
```
